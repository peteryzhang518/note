# 重要的思想
1.
目前来看，我所学的内容有一部分是stm32平台的内容，很多事项是stm公司提供的硬件接口，需要查看操作手册
2.
如果大型的项目，比如你想制造一个遥控车，这个时候可能就会需要使用到系统，一旦你对系统进行了选择，大部分情况下，你是不需要对底层硬件有很大的了解了，因为很多硬件平台，比如说stm32,已经被系统所支持，这样很大程度上你是可以和调用os系统的接口，而不是单独学习stm32的裸机程序接口

# 操作系统的硬件抽象

在大多数现代操作系统中，操作系统会提供一定的硬件抽象层（HAL）或标准接口（例如 POSIX），这些接口隐藏了硬件的差异，使得开发者只需要关注操作系统提供的高层功能，而不需要关心底层硬件的具体细节。

- 这种 硬件抽象 的目标是：

    简化开发：开发者不需要了解硬件细节，避免直接操作硬件接口，只需调用操作系统提供的统一接口。
    跨平台兼容性：同一个操作系统可以运行在不同的硬件平台上，开发者的代码可以跨平台运行，只要操作系统提供了相应的硬件抽象接口。
    硬件独立性：操作系统的设计考虑到了硬件差异，抽象层屏蔽了不同硬件平台的特性，使得应用程序代码与硬件平台解耦。

- 具体的操作系统如何提供抽象接口

1. POSIX 标准：

        POSIX（可移植操作系统接口）是一个针对操作系统的标准，它定义了许多 系统调用接口，使得应用程序可以在不同的硬件平台和操作系统之间移植。例如，POSIX 提供了对文件操作、进程管理、线程调度、信号处理等的标准接口。这些接口隐藏了硬件细节，使得开发者无需了解底层硬件的实现，只要遵循 POSIX 标准，应用程序就可以在支持 POSIX 的操作系统上运行。

        常见的 POSIX 系统包括 Linux、macOS、FreeBSD 等，它们都提供了统一的接口来操作硬件资源，而无需直接访问硬件。

2. 操作系统的硬件抽象层（HAL）：

        一些操作系统，特别是 嵌入式操作系统，会实现一个 硬件抽象层（HAL），它屏蔽了硬件平台的差异，提供了一个统一的接口供上层应用使用。例如，FreeRTOS、NuttX 等嵌入式操作系统都提供了 HAL，使得开发者可以在不同的硬件平台上使用相同的 API 进行开发，而不需要直接访问硬件的底层接口。

        FreeRTOS 和 NuttX 都会针对不同的硬件平台实现相应的 HAL，开发者只需调用操作系统的 API 来实现任务调度、外设控制等功能，操作系统会负责与硬件的交互。

3. 设备驱动程序：

        操作系统通常会提供 设备驱动程序，用于与硬件的不同部件（如串口、GPIO、I2C、SPI 等）进行交互。设备驱动程序对外提供统一的接口，而开发者只需通过这些接口与外设通信，而无需知道硬件的细节实现。

        例如，Linux 中的 I2C 驱动 会提供一个统一的接口，使得开发者只需要调用 I2C 的系统调用接口进行通信，而不需要关注具体硬件如何工作。类似地，FreeRTOS 和 NuttX 也会提供一套设备驱动 API。
        

总结：
板级支持包（BSP）是介于主板硬件和操作系统中驱动层程序之间的一层，一般认为它属于操作系统一部分，主要是实现对操作系统的支持，为上层的驱动程序提供访问硬件设备 寄存器的函数包，使之能够更好的运行于硬件主板。在嵌入式系统软件的组成中，就有BSP。BSP是相对于操作系统而言的，不同的操作系统对应于不同定义形式的BSP，例如VxWorks的BSP和 Linux的BSP相对于某一 CPU来说尽管实现的功能一样，可是写法和 接口定义是完全不同的，所以写BSP一定要按照该系统BSP的定义形式来写（BSP的编程过程大多数是在某一个 成型的BSP模板上进行修改）。这样才能与上层OS保持正确的接口，良好的支持上层OS。

板级支持包BSP（Board Support Package）是外设、硬件的驱动软件集合。单独使用BSP即可在嵌入式系统上开发应用。BSP也可以按照规范编写为操作系统（VxWorks、Linux等）提供接口。

但是由于日益增长的芯片种类和芯片复杂度，每种芯片的外设寄存器地址和控制方式都各不一样，针对每种Board编写BSP工作量很大。一般公司例如ST会提供HAl库，用户可以忽略寄存器的繁杂操作，直接调用HAL库函数即可进行芯片内部外设操作，大大降低BSP软件的开发周期。加入HAL库之后的系统软件结构如下图所示：

引入HAL之后操作系统将会使用相对更为统一的HAL接口来实现对硬件的操作，而不是直接使用BSP库。

还有人提出了固件的概念，这可能是两个比较复杂的芯片一起使用，比如cpu使用网卡，网卡里面的程序就叫做固件

hardware --> hardware abstract layer --> board support package --> driver --> operating system --> application
当然嵌入式系统中操作系统并不是必须的，并且在操作系统和应用程序之间可以在有一层中间件Middleware层，用于提供更多的系统功能，这个中间件Middleware层也被称作SDK。



# 可以运行在有mmu的硬件平台上的操作系统
1. Nuttx
2. FreeRTos
# 可以运行在没有mmu的硬件平台上的操作系统
1. Nuttx
2. FreeRTos
# 最大程度兼容posix操作系统的嵌入式系统

1. NuttX
    概述：
        NuttX 是一个 开源实时操作系统 (RTOS)，特别适合 嵌入式系统。它的目标是为资源受限的硬件提供 POSIX 兼容的实时操作系统。NuttX 提供 多任务调度、线程管理、信号、IPC 等 POSIX 标准功能，广泛应用于 嵌入式设备、物联网、机器人、无人机 等领域。

2. RTEMS (Real-Time Executive for Multiprocessor Systems)
    概述：
        RTEMS 是一个全功能的 实时操作系统，广泛用于 嵌入式、航空航天、工业控制等领域。它致力于提供 硬实时 性能，并且具有很强的 POSIX 兼容性，特别适合在嵌入式系统中运行。

# uclinux不算是最大程度兼容 POSIX 标准 的 开源嵌入式实时操作系统么
uClinux 作为一个 开源嵌入式实时操作系统，确实在嵌入式系统中广泛应用，但它并不被视为 最大程度兼容 POSIX 标准 的 RTOS。下面是对 uClinux 的一些分析，帮助解释为什么它不完全符合 POSIX 标准的要求。
1. uClinux 概述
    uClinux 是一个专为 无内存管理单元（MMU）的嵌入式系统 设计的 Linux 变种。它主要被用于那些内存受限的设备，如一些低成本的嵌入式硬件、微控制器、嵌入式开发板等。uClinux 保留了大部分 Linux 核心的特性，但做了一些精简，以便适应无 MMU 的平台。
    它的特点是：
        基于 Linux 核心，使用与 Linux 相似的工具链和开发环境。
        通过修改 Linux 内核，使其能够在没有 MMU（内存管理单元）的处理器上运行。
        适用于嵌入式系统、路由器、通信设备等资源有限的硬件。

2. POSIX 兼容性
    uClinux 和 POSIX 兼容性：
        uClinux 不完全兼容 POSIX 标准，尽管它是基于 Linux 内核的变种，Linux 本身对 POSIX 标准有广泛的支持。
        uClinux 在设计上侧重于 低资源消耗 和 小内存占用，因此在内核中移除了某些与内存管理相关的特性（例如虚拟内存）。这使得其 POSIX 支持不完整，特别是在 内存管理（如虚拟内存和内存映射） 和 进程管理 方面。
        文件系统、线程、信号 等 POSIX 的基本功能通常得到了支持，但 进程管理 和 内存管理 方面的支持有所不足，特别是因为 uClinux 不提供 完整的 MMU 功能。

3. 实时性
    uClinux 的实时性：
        uClinux 由于是基于 Linux 的，拥有类似于 Linux 的调度器，但它本身并不是一个 实时操作系统。尽管它能提供基础的任务调度，但如果要满足严格的 硬实时 性能，uClinux 可能不适合。
        uClinux 可以通过补丁或集成其他实时框架（如 RT-Preempt）来增强实时性，但本身并没有像 RTEMS 或 Xenomai 这样的硬实时特性。





# nuttx系统详解
由于nuttx是很大程度还原了unixapi的嵌入式系统,所以用他来了解系统是一个非常好的流程
首先由于freeos太国简单，所以freeos基本上是没有所谓的hal层的概念的
但是nuttx系统是有hal层的概念

由于nuttx系统是可以装在stm32上，所以用stm32来举例说，假设，如果要使用stm32的某一个gpio接口也是通过gpio_write等函数
```
    // 设置 GPIO 13 为输出
    gpio_direction_out(GPIO_PIN, true);

    // 控制 GPIO 13 输出高电平
    gpio_write(GPIO_PIN, true);  
    syslog(LOG_INFO, "GPIO 13 is HIGH\n");
```

那nuttux如何知道gpio的引脚地址呢,通常有两个步骤
    1. 硬件抽象层（HAL）和 GPIO 映射
NuttX 为不同的硬件平台提供了硬件抽象层（HAL），该层通常定义了具体的硬件引脚配置和映射。HAL 层将 GPIO 引脚的物理地址 与 逻辑 GPIO 编号 关联起来，允许开发者通过逻辑编号来操作硬件。
例如，在 STM32 上，GPIO 引脚的配置会定义在平台相关的源码中，通常在 NuttX 的 arch/arm/src/stm32 目录下。
```
#define GPIO_PIN_0   (1 << 0)  // GPIO Pin 0
#define GPIO_PIN_1   (1 << 1)  // GPIO Pin 1
// ...
#define GPIO_PIN_13  (1 << 13) // GPIO Pin 13
```
这些引脚宏定义了引脚的逻辑编号，GPIO 0 对应第一个物理引脚，GPIO 1 对应第二个物理引脚，以此类推。
在 NuttX 启动时，硬件抽象层会根据硬件平台的定义来初始化引脚配置，确保每个引脚的状态（输入/输出）与相应的物理引脚匹配。
    2. 设备树（Device Tree）和 GPIO 配置
在一些硬件平台上，特别是 ARM 架构的平台，NuttX 也支持使用 设备树（Device Tree）来描述硬件配置信息。设备树是一种数据结构，用于描述硬件设备的地址、寄存器映射和引脚配置。

设备树文件（通常为 .dts 文件）描述了硬件的布局，包括 GPIO 引脚的配置。在设备树文件中，每个 GPIO 引脚都会与特定的 物理引脚 和 功能 关联。例如，在 STM32 系列的设备树文件中，GPIO 引脚的配置可能看起来像这样：

总结：
首先来说一般系统里面会有一些文件定义了gpio或者其他引脚的地址，并将起抽象为一个名字，比如gpio1等等
然后,系统会通过dtsi等文件再次将其抽象为一个i2c或者其他的设备,这个时候你想让这个引脚是gpio，他就是gpio，你想让他复用成i2c他就是i2c阿
设备树并不直接指定 GPIO 引脚的物理地址，而是通过 pinctrl 管理引脚功能。在 STM32 系统中，设备树中的引脚配置将映射到 arch/arm/src/stm32 中定义的硬件引脚和寄存器。

# 在选定硬件平台后，基地址之类的地址就确定了，为什么引脚可以抽象到arch/stm文件夹下面，但是通常不抽象基地址
在嵌入式系统中，硬件的 寄存器基地址 和 引脚的功能配置 虽然都属于硬件相关的配置，但它们的抽象层级和作用不同，因此在处理它们时，通常采用不同的策略。让我们来深入理解一下为什么 引脚功能配置 可以在 arch/arm/src/stm32 这样的文件夹中进行抽象，而 寄存器基地址 通常不会这样做。
1. 寄存器基地址的不可抽象性

寄存器基地址（如 0x40005400）是硬件设计的固有特性。每个外设（如 I2C、SPI、UART 等）的寄存器都被映射到系统内存的特定位置，这些位置在硬件设计时就已经决定了。它们是物理地址，并且对操作系统来说是固定的、不可改变的。因此，在设备树或者代码中，寄存器基地址通常以 十六进制的数字 固定写出。
为什么不抽象寄存器基地址？

    硬件映射固定：寄存器基地址是由硬件设计直接决定的，这些地址在硬件层次上是已经定义好的。无论你使用什么操作系统或者驱动程序，这些地址都不会改变，因此不需要通过抽象化的方式来处理。

    直接操作硬件：寄存器的作用是直接控制硬件外设，操作系统和驱动程序需要通过特定的内存地址访问这些寄存器来进行硬件初始化、配置和操作。这些物理地址需要在代码中显式给出，才能保证驱动程序正确与硬件交互。

    硬件描述的一致性：不同硬件平台的寄存器映射可能会有所不同，因此寄存器基地址必须严格按照硬件的规格来定义，并且通常直接在驱动程序中使用这些地址。而 抽象化寄存器基地址 可能会使得硬件平台间的兼容性变得更加复杂。

2. 引脚功能配置的抽象性

与寄存器基地址不同，引脚功能配置 更多的是一个逻辑配置，而不是固定的硬件物理地址。虽然每个引脚也有对应的物理地址，但是引脚的 功能（例如是否作为 GPIO、I2C SDA、SPI SCK 引脚）是由硬件的 引脚复用功能（pinmux）控制的，并且可以根据需求进行灵活配置。
为什么引脚功能可以抽象化？

    灵活的引脚复用：大多数嵌入式系统的引脚（特别是 STM32 等微控制器）支持 引脚复用（pinmux）。即同一个物理引脚可以根据不同的需求配置为不同的功能（例如：一个引脚可以作为 GPIO、I2C SDA、SPI MOSI 等）。这就使得引脚配置需要具有 抽象性，以便在不同的应用场景下灵活配置。

    平台无关性：引脚的功能配置是由 引脚复用控制器（Pinmux） 来管理的，这样的配置通常不依赖于硬件平台的具体实现，而是可以通过一些抽象的 API 来进行控制。在设备树中，开发者可以用一种抽象的方式来描述引脚的功能，而无需关心物理地址。

    设备树中的抽象：设备树在描述硬件时，通常将硬件的 功能 抽象为某个 符号（如 i2c1_sda，uart1_tx），这些符号代表了硬件引脚所支持的功能，而具体的引脚位置和控制会在底层硬件抽象层（HAL）或者驱动程序中处理。

示例：引脚功能的抽象

在 STM32 或类似的微控制器中，设备树中会这样描述引脚功能：

&i2c1 {
    status = "okay";
    clock-frequency = <100000>;
    pinctrl-0 = <&i2c1_scl &i2c1_sda>;  // 引脚的抽象功能
    pinctrl-names = "default";
};

这里的 i2c1_scl 和 i2c1_sda 并不是物理引脚的地址，而是 引脚的功能配置，用于指定这两个引脚将作为 I2C 总线的 SCL 和 SDA 引脚。

这些符号通过 引脚复用控制器（pinmux）来映射到具体的物理引脚，并在底层硬件抽象层中完成最终的硬件配置。开发者只需要关心引脚的功能，而不必处理硬件引脚的物理地址。
3. 引脚和寄存器基地址的职责差异

    寄存器基地址：表示外设硬件的物理位置，这些地址是由硬件设计决定的，是 固定的，不可改变的。操作系统和驱动程序需要使用这些地址来控制外设。没有抽象化的空间，因为它们是硬件设计的结果。

    引脚功能配置：描述的是引脚的 功能，而不是它们的物理位置。引脚的功能是由引脚复用控制器决定的，通常支持多种功能，可以根据需要灵活配置。因此，引脚配置具有较高的抽象性。

4. 总结

    寄存器基地址 通常 不抽象化，因为它们是硬件固定的物理地址，直接影响到外设的控制。硬件平台的寄存器基地址通常会在驱动程序中直接使用，并且由硬件文档来提供。

    引脚功能 可以通过设备树进行 抽象化，因为它们代表的是引脚的功能而非物理地址。引脚可以通过引脚复用控制器（pinmux）来进行功能配置，因此可以在软件中抽象化处理，提升灵活性和可配置性。

# dtsi运行状态
    1. 内核启动加载 DTB 文件
在嵌入式系统启动时，内核会通过引导加载程序（例如 U-Boot）加载设备树二进制文件（dtb）。设备树会通过内核启动参数传递给内核，内核从启动命令行或其他配置中获取 dtb 文件的位置并加载。
    2. 设备树如何与内核交互
当 Linux 内核启动并加载设备树文件后，内核会解析设备树中的信息并使用它来初始化硬件和设备。设备树主要用于向内核提供硬件配置，并且内核会根据设备树中的信息来：
    配置外设：内核驱动会通过设备树获取外设的配置信息，例如寄存器地址、中断号、时钟等，来初始化外设。
    注册设备：设备树中的信息会帮助内核注册和初始化各种硬件设备，如 I2C、SPI、GPIO、串口等。

# bsp和驱动的一些区别
    BSP 初始化：在 stm32_i2c.c 中，BSP 初始化了 I2C 控制器，并配置了 I2C 总线的时钟、引脚等。此时硬件平台上的 I2C 外设被准备好，但还没有进行具体的操作。

    驱动程序注册：I2C 驱动程序会使用 NuttX 的设备模型，将 I2C 驱动注册到系统中。在注册过程中，设备驱动会向 NuttX 注册自己的操作接口，供应用程序或其他系统模块调用。例如，i2c_master.c 中可能会定义 i2c_read() 和 i2c_write() 等接口。

    驱动程序的操作：应用程序或者其他模块通过访问 I2C 设备的文件描述符来与 I2C 外设进行交互。当应用程序打开 /dev/i2c0（假设 I2C 设备注册在该路径下）时，NuttX 会调用 i2c_master.c 中的函数来实际进行数据读写。

个人总结：bsp也就是一些涉及到和引脚有关，比如拉低拉高，把这些内容抽象成函数的一些内容
而驱动，既然有驱动的概念，证明在系统中，也就是里面的很多内容有关与系统，比如说，如何创建设备，如何注册设备，read，read函数去寻找到i2c——transfer，然后找到bsp中的i2c代码，也就是说驱动调用了bsp中的代码,有的时候在概念上是很相近的，所以并不是很好区分
BSP 代码 stm32_i2c.c 负责初始化硬件控制器I2C,会设置时钟、配置 GPIO 引脚以及启用 I2C 控制器。旦硬件初始化完成，NuttX 内核中的 I2C 驱动程序（如 i2c_master.c）可以通过 外设驱动 API（如 i2c_transfer()）与已经初始化的 I2C 控制器进行交互。


# nuttx启动bsp函数及顺序
NuttX 中调用 BSP 代码的过程
    启动代码和硬件初始化： 在 NuttX 启动时，up_initialize() 是一个关键函数，它会调用 BSP 中的硬件初始化代码。up_initialize() 函数通常位于 arch/ 目录下，具体路径和文件名依赖于你的硬件平台。
    系统启动过程：
        up_initialize() 是 NuttX 启动过程中的一个重要函数。它在系统启动时被调用，主要任务是初始化硬件平台的各种资源（如时钟、GPIO 引脚、外设等）。
        具体的硬件初始化函数会根据硬件平台的不同而有所不同，例如在 STM32 平台上，stm32_boardinitialize() 会在 up_initialize() 中被调用。这个函数会配置和初始化硬件资源，如引脚、I2C、UART、SPI 等外设。

drivers的调用
        /****************************************************************************
 * Name: drivers_initialize
 *
 * Description:
 *   drivers_initialize will be called once during OS initialization after
 *   the basic OS services have been initialized.
 *
 *   drivers_initialize is called after the OS initialized but before the
 *   user initialization logic has been started and before the libraries
 *   have been initialized.  OS services and driver services are available.
 *
 ****************************************************************************/

void drivers_initialize(void)
{
  drivers_trace_begin();

  /* Register devices */

  syslog_initialize();

#ifdef CONFIG_SERIAL_RTT
  serial_rtt_initialize();
#endif

#if defined(CONFIG_DEV_NULL)
  devnull_register();   /* Standard /dev/null */
#endif
